<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>How to make your own VST host</title>

    <link rel="stylesheet" href="/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="stylesheet" href="/css/pygments.css" type="text/css" />

    <script language="javascript" src="/js/email.js"></script>
    <!-- google analytics -->
<script type='text/javascript'> 
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type='text/javascript'> 
  var pageTracker = _gat._getTracker("UA-4400684-1");
  pageTracker._initData();
  pageTracker._trackPageview();
</script>

  </head>
  <body>
  <div id="smallheader">
    <div class="wrapper">
      <div id="logo">
        <a href="/"><img src="/images/ta_logo_inverted.png" alt="Teragon Audio"/></a>
      </div>
        
      <!--
      <div id="right">
        <form method="get" id="searchform" action="#"> 
          <fieldset class="search"> 
            <input type="text" class="box" /> 
            <button class="btn" title="Search">Search</button> 
          </fieldset> 
        </form>
      </div> 
      -->
    </div>
  </div>
  <div id="contentpart">
    <div class="wrapper">
      <ul class="menu">
  <li class="menuitem"><a href="index.html">Home</a></li>
  <li class="menuitem"><a href="/software.html">Software</a></li>
  <li class="menuitem"><a href="/developers.html">Developer Portal</a></li>
  <li class="menuitem"><a href="/performers.html">Performer Portal</a></li>
  <li class="menuitem"><a href="/contact.html">Contact</a></li>
</ul> 


      <div id="content">						
        <div class="title">
          <h1>
            How to make your own VST host
          </h1>
        </div>

        <!-- Start content -->
        <h2 id='introduction'>Introduction</h2>

<p>Writing VST plugins is a lot of fun, but it&#8217;s even more fun to write your own host which uses the wide variety of plugins already out there to do something original and new. Making your own VST host is not a trivial task, but the trickiest part is figuring out how to load the plugins and connect them to your code&#8217;s callback functions. As the VST documentation is a bit sparse on the subject of hosting, this guide will assist you in setting up your own host.</p>

<p>This guide only covers loading the plugin and basic communication, and the language of choice here is C++. C# programmers should consider using the <a href='http://www.codeplex.com/vstnet'>VST.NET framework</a>, and I&#8217;m not sure what frameworks exist for other languages.</p>

<p>Also, it&#8217;s worth noting that Teragon Audio has developed an <a href='http://teragonaudio.github.com/MrsWatson'>open-source VST host, MrsWatson</a>. Feel free to look at the code and fork it for your own project! If you find yourself using a substantial portion of the MrsWatson source in your own code, please let me know so I can add a link to your project from the MrsWatson page.</p>

<h2 id='code_conventions'>Code conventions</h2>

<p>In the course of your development, you will probably require logging, error handling, etc. To simplify the code in this tutorial, I have simply written &#8220;return -1&#8221; or &#8220;return NULL&#8221; statements, but you should consider expanding this to log some info or handle the error.</p>

<p>Also, this tutorial is written for both Windows and Mac OSX developers. As such, there is a lot of platform-specific code, which you will probably need to box with #ifdef/#endif statements in the preprocessor.</p>

<h2 id='setting_up_your_build_environment'>Setting up your build environment</h2>

<p>You&#8217;ll need to first download and install the following tools:</p>

<ol>
<li><a href='http://www.steinberg.net/en/company/3rd_party_developer.html'>Steinberg&#8217;s VST SDK</a>, which requires you to make a <a href='http://www.steinberg.net/en/company/3rd_party_developer/sdk_download_portal/create_3rd_party_developer_account.html'>free Steinberg Developer account</a>. This tutorial assumes you are working with the VST 2.4 SDK.</li>

<li><a href='http://msdn.microsoft.com/vstudio/express/visualc/'>Microsoft&#8217;s Visual C++ 2010 Express</a>, if you wish to support Windows.</li>

<li><a href='http://www.microsoft.com/downloads/details.aspx?FamilyId=0BAF2B35-C656-4969-ACE8-E4C0C0716ADB&amp;displaylang=en'>Microsoft&#8217;s Platform SDK</a>, again if you are developing on Windows.</li>

<li><a href='http://developer.apple.com/programs/mac/'>Xcode 4.x</a>, if you are developing on Mac OS X.</li>
</ol>

<h2 id='project_configuration'>Project configuration</h2>

<p>Aside from your project files, you need only to add the VST SDK headers into your project&#8217;s include path. This includes the following files, which are located under the vstsdk2.4/pluginterfaces/vst2.x directory:</p>

<ul>
<li>aeffect.h</li>

<li>aeffectx.h</li>

<li>vsfxstore.h</li>
</ul>

<p>On both Windows and Mac OSX, you should probably configure your program to build as a 32-bit binary, simply because most VST plugins are not 64-bit compatible yet. On the Mac, this gets to be a bit hairy because Apple is working to deprecate Carbon, which is a 32-bit framework. If anyone out there has example code in C (not objective-C) to load a plugin from bundle without using Carbon, please let me know so I can update this article.</p>

<h2 id='loading_the_vst_plugin'>Loading the VST plugin</h2>

<p>After your host performs its own internal initialization routines, it is time to load the VST plugin from source. This procedure varies a bit depending on the platform, but the algorithm is fundamentally the same: find the plugin, load the dynamic library into memory, acquire the plugin&#8217;s main address, and create a VST callback connection. These callbacks are defined function pointers which you should define in one of your project&#8217;s header files, and are as follows:</p>
<div class='highlight'><pre><code class='cpp'><span class='cp'>#include &quot;aeffectx.h&quot;</span>

<span class='c1'>// C callbacks</span>
<span class='k'>extern</span> <span class='s'>&quot;C&quot;</span> <span class='p'>{</span>
<span class='c1'>// Main host callback</span>
  <span class='n'>VstIntPtr</span> <span class='n'>VSTCALLBACK</span> <span class='n'>hostCallback</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>effect</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>opcode</span><span class='p'>,</span>
    <span class='n'>VstInt32</span> <span class='n'>index</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>value</span><span class='p'>,</span> <span class='kt'>void</span> <span class='o'>*</span><span class='n'>ptr</span><span class='p'>,</span> <span class='kt'>float</span> <span class='n'>opt</span><span class='p'>);</span>
<span class='p'>}</span>

<span class='c1'>// Plugin&#39;s entry point</span>
<span class='k'>typedef</span> <span class='n'>AEffect</span> <span class='o'>*</span><span class='p'>(</span><span class='o'>*</span><span class='n'>vstPluginFuncPtr</span><span class='p'>)(</span><span class='n'>audioMasterCallback</span> <span class='n'>host</span><span class='p'>);</span>
<span class='c1'>// Plugin&#39;s dispatcher function</span>
<span class='k'>typedef</span> <span class='n'>VstIntPtr</span> <span class='p'>(</span><span class='o'>*</span><span class='n'>dispatcherFuncPtr</span><span class='p'>)(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>effect</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>opCode</span><span class='p'>,</span>
  <span class='n'>VstInt32</span> <span class='n'>index</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>value</span><span class='p'>,</span> <span class='kt'>void</span> <span class='o'>*</span><span class='n'>ptr</span><span class='p'>,</span> <span class='kt'>float</span> <span class='n'>opt</span><span class='p'>);</span>
<span class='c1'>// Plugin&#39;s getParameter() method</span>
<span class='k'>typedef</span> <span class='kt'>float</span> <span class='p'>(</span><span class='o'>*</span><span class='n'>getParameterFuncPtr</span><span class='p'>)(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>effect</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>index</span><span class='p'>);</span>
<span class='c1'>// Plugin&#39;s setParameter() method</span>
<span class='k'>typedef</span> <span class='kt'>void</span> <span class='p'>(</span><span class='o'>*</span><span class='n'>setParameterFuncPtr</span><span class='p'>)(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>effect</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>index</span><span class='p'>,</span> <span class='kt'>float</span> <span class='n'>value</span><span class='p'>);</span>
<span class='c1'>// Plugin&#39;s processEvents() method</span>
<span class='k'>typedef</span> <span class='n'>VstInt32</span> <span class='p'>(</span><span class='o'>*</span><span class='n'>processEventsFuncPtr</span><span class='p'>)(</span><span class='n'>VstEvents</span> <span class='o'>*</span><span class='n'>events</span><span class='p'>);</span>
<span class='c1'>// Plugin&#39;s process() method</span>
<span class='k'>typedef</span> <span class='kt'>void</span> <span class='p'>(</span><span class='o'>*</span><span class='n'>processFuncPtr</span><span class='p'>)(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>effect</span><span class='p'>,</span> <span class='kt'>float</span> <span class='o'>**</span><span class='n'>inputs</span><span class='p'>,</span>
  <span class='kt'>float</span> <span class='o'>**</span><span class='n'>outputs</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>sampleFrames</span><span class='p'>);</span>
</code></pre>
</div>
<p>On Windows, VST plugins are simply dynamically linked libraries (DLL&#8217;s). The code for opening a DLL library in Windows is fairly simple:</p>
<div class='highlight'><pre><code class='cpp'><span class='n'>AEffect</span><span class='o'>*</span> <span class='n'>loadPlugin</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span> <span class='o'>=</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='kt'>char</span> <span class='o'>*</span><span class='n'>vstPath</span> <span class='o'>=</span> <span class='s'>&quot;c:</span><span class='se'>\\</span><span class='s'>wherever</span><span class='se'>\\</span><span class='s'>the</span><span class='se'>\\</span><span class='s'>plugin</span><span class='se'>\\</span><span class='s'>is</span><span class='se'>\\</span><span class='s'>located.vst&quot;</span><span class='p'>;</span>

  <span class='n'>modulePtr</span> <span class='o'>=</span> <span class='n'>LoadLibrary</span><span class='p'>(</span><span class='n'>vstPath</span><span class='p'>);</span>
  <span class='k'>if</span><span class='p'>(</span><span class='n'>modulePtr</span> <span class='o'>==</span> <span class='nb'>NULL</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;Failed trying to load VST from &#39;%s&#39;, error %d</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>,</span>
      <span class='n'>vstPath</span><span class='p'>,</span> <span class='n'>GetLastError</span><span class='p'>());</span>
    <span class='k'>return</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='n'>vstPluginFuncPtr</span> <span class='n'>mainEntryPoint</span> <span class='o'>=</span>
    <span class='p'>(</span><span class='n'>vstPluginFuncPtr</span><span class='p'>)</span><span class='n'>GetProcAddress</span><span class='p'>(</span><span class='n'>modulePtr</span><span class='p'>,</span> <span class='s'>&quot;VSTPluginMain&quot;</span><span class='p'>);</span>
  <span class='c1'>// Instantiate the plugin</span>
  <span class='n'>plugin</span> <span class='o'>=</span> <span class='n'>mainEntryPoint</span><span class='p'>(</span><span class='n'>hostCallback</span><span class='p'>);</span>
  <span class='k'>return</span> <span class='n'>plugin</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>On Mac OSX, VST plugins are also dynamic libraries, but they are packaged as bundles. Your host can open these bundles through the Carbon API. On Mac OS9, VST plugins were packaged as CFM files, which has long since been deprecated, and it is highly unlikely that any modern VST host should need to support this format.</p>

<p>The procedure for opening a plugin under OSX is a bit more complex, but the code should be fairly straightforward. Keep in mind that although a VST plugin can be loaded from any location on disk, they are usually stored in either <code>/Library/Audio/Plug-Ins/VST</code> or <code>$HOME/Library/Audio/Plug-Ins/VST</code>.</p>

<p>Anyways, to load the VST plugin on Mac OSX, that will look something like this:</p>
<div class='highlight'><pre><code class='cpp'><span class='n'>AEffect</span><span class='o'>*</span> <span class='n'>loadPlugin</span><span class='p'>()</span> <span class='p'>{</span>
  <span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span> <span class='o'>=</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='n'>audioMasterCallback</span> <span class='n'>hostCallbackFuncPtr</span> <span class='o'>=</span> <span class='n'>hostCallback</span><span class='p'>;</span>
  <span class='kt'>char</span> <span class='o'>*</span><span class='n'>pluginPath</span> <span class='o'>=</span> <span class='s'>&quot;/wherever/the/plugin/is/located.vst&quot;</span><span class='p'>;</span>

  <span class='c1'>// Create a path to the bundle</span>
  <span class='n'>CFStringRef</span> <span class='n'>pluginPathStringRef</span> <span class='o'>=</span> <span class='n'>CFStringCreateWithCString</span><span class='p'>(</span><span class='nb'>NULL</span><span class='p'>,</span>
    <span class='n'>pluginPath</span><span class='p'>,</span> <span class='n'>kCFStringEncodingASCII</span><span class='p'>);</span>
  <span class='n'>CFURLRef</span> <span class='n'>bundleUrl</span> <span class='o'>=</span> <span class='n'>CFURLCreateWithFileSystemPath</span><span class='p'>(</span><span class='n'>kCFAllocatorDefault</span><span class='p'>,</span>
    <span class='n'>pluginPathStringRef</span><span class='p'>,</span> <span class='n'>kCFURLPOSIXPathStyle</span><span class='p'>,</span> <span class='kc'>true</span><span class='p'>);</span>
  <span class='k'>if</span><span class='p'>(</span><span class='n'>bundleUrl</span> <span class='o'>==</span> <span class='nb'>NULL</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;Couldn&#39;t make URL reference for plugin</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>);</span>
    <span class='k'>return</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='c1'>// Open the bundle</span>
  <span class='n'>CFBundleRef</span> <span class='n'>bundle</span><span class='p'>;</span>
  <span class='n'>bundle</span> <span class='o'>=</span> <span class='n'>CFBundleCreate</span><span class='p'>(</span><span class='n'>kCFAllocatorDefault</span><span class='p'>,</span> <span class='n'>bundleUrl</span><span class='p'>);</span>
  <span class='k'>if</span><span class='p'>(</span><span class='n'>bundle</span> <span class='o'>==</span> <span class='nb'>NULL</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;Couldn&#39;t create bundle reference</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>);</span>
    <span class='n'>CFRelease</span><span class='p'>(</span><span class='n'>pluginPathStringRef</span><span class='p'>);</span>
    <span class='n'>CFRelease</span><span class='p'>(</span><span class='n'>bundleUrl</span><span class='p'>);</span>
    <span class='k'>return</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='n'>vstPluginFuncPtr</span> <span class='n'>mainEntryPoint</span> <span class='o'>=</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='n'>mainEntryPoint</span> <span class='o'>=</span> <span class='p'>(</span><span class='n'>vstPluginFuncPtr</span><span class='p'>)</span><span class='n'>CFBundleGetFunctionPointerForName</span><span class='p'>(</span><span class='n'>bundle</span><span class='p'>,</span>
    <span class='n'>CFSTR</span><span class='p'>(</span><span class='s'>&quot;VSTPluginMain&quot;</span><span class='p'>));</span>
  <span class='c1'>// VST plugins previous to the 2.4 SDK used main_macho for the entry point name</span>
  <span class='k'>if</span><span class='p'>(</span><span class='n'>mainEntryPoint</span> <span class='o'>==</span> <span class='nb'>NULL</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>mainEntryPoint</span> <span class='o'>=</span> <span class='p'>(</span><span class='n'>vstPluginFuncPtr</span><span class='p'>)</span><span class='n'>CFBundleGetFunctionPointerForName</span><span class='p'>(</span><span class='n'>bundle</span><span class='p'>,</span>
      <span class='n'>CFSTR</span><span class='p'>(</span><span class='s'>&quot;main_macho&quot;</span><span class='p'>));</span>
  <span class='p'>}</span>

  <span class='k'>if</span><span class='p'>(</span><span class='n'>mainEntryPoint</span> <span class='o'>==</span> <span class='nb'>NULL</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;Couldn&#39;t get a pointer to plugin&#39;s main()</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>);</span>
    <span class='n'>CFBundleUnloadExecutable</span><span class='p'>(</span><span class='n'>bundle</span><span class='p'>);</span>
    <span class='n'>CFRelease</span><span class='p'>(</span><span class='n'>bundle</span><span class='p'>);</span>
    <span class='k'>return</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='n'>plugin</span> <span class='o'>=</span> <span class='n'>mainEntryPoint</span><span class='p'>(</span><span class='n'>hostCallback</span><span class='p'>);</span>
  <span class='k'>if</span><span class='p'>(</span><span class='n'>plugin</span> <span class='o'>==</span> <span class='nb'>NULL</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;Plugin&#39;s main() returns null</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>);</span>
    <span class='n'>CFBundleUnloadExecutable</span><span class='p'>(</span><span class='n'>bundle</span><span class='p'>);</span>
    <span class='n'>CFRelease</span><span class='p'>(</span><span class='n'>bundle</span><span class='p'>);</span>
    <span class='k'>return</span> <span class='nb'>NULL</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='c1'>// Clean up</span>
  <span class='n'>CFRelease</span><span class='p'>(</span><span class='n'>pluginPathStringRef</span><span class='p'>);</span>
  <span class='n'>CFRelease</span><span class='p'>(</span><span class='n'>bundleUrl</span><span class='p'>);</span>

  <span class='k'>return</span> <span class='n'>plugin</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>You need to keep the bundle pointer around until the host is ready to unload the plugin. At this point, you call <code>CFBundleUnloadExecutable</code> and then <code>CFRelease</code> on the bundle&#8217;s reference.</p>

<h2 id='setting_up_plugin_callbacks'>Setting up plugin callbacks</h2>

<p>At this point, you should now have successfully loaded the plugin into memory, and you can now establish the plugin dispatcher callbacks:</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>int</span> <span class='n'>initPlugin</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// Check plugin&#39;s magic number</span>
  <span class='c1'>// If incorrect, then the file either was not loaded properly, is not a</span>
  <span class='c1'>// real VST plugin, or is otherwise corrupt.</span>
  <span class='k'>if</span><span class='p'>(</span><span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>magic</span> <span class='o'>!=</span> <span class='n'>kEffectMagic</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;Plugin&#39;s magic number is bad</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>);</span>
    <span class='k'>return</span> <span class='o'>-</span><span class='mi'>1</span><span class='p'>;</span>
  <span class='p'>}</span>

  <span class='c1'>// Create dispatcher handle</span>
  <span class='n'>dispatcherFuncPtr</span> <span class='n'>dispatcher</span> <span class='o'>=</span> <span class='p'>(</span><span class='n'>dispatcherFuncPtr</span><span class='p'>)(</span><span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>dispatcher</span><span class='p'>);</span>

  <span class='c1'>// Set up plugin callback functions</span>
  <span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>getParameter</span> <span class='o'>=</span> <span class='p'>(</span><span class='n'>getParameterFuncPtr</span><span class='p'>)</span><span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>getParameter</span><span class='p'>;</span>
  <span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>processReplacing</span> <span class='o'>=</span> <span class='p'>(</span><span class='n'>processFuncPtr</span><span class='p'>)</span><span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>processReplacing</span><span class='p'>;</span>
  <span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>setParameter</span> <span class='o'>=</span> <span class='p'>(</span><span class='n'>setParameterFuncPtr</span><span class='p'>)</span><span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>setParameter</span><span class='p'>;</span>

  <span class='k'>return</span> <span class='n'>plugin</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre>
</div>
<h2 id='plugin_initialization'>Plugin initialization</h2>

<p>At this point, the plugin should be ready to go, so you can initialize it through the dispatcher handle created in the previous step:</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>void</span> <span class='n'>initPlugin</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>effOpen</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='nb'>NULL</span><span class='p'>,</span> <span class='mf'>0.0f</span><span class='p'>);</span>

  <span class='c1'>// Set some default properties</span>
  <span class='kt'>float</span> <span class='n'>sampleRate</span> <span class='o'>=</span> <span class='mf'>44100.0f</span><span class='p'>;</span>
  <span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>effSetSampleRate</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='nb'>NULL</span><span class='p'>,</span> <span class='n'>sampleRate</span><span class='p'>);</span>
  <span class='kt'>int</span> <span class='n'>blocksize</span> <span class='o'>=</span> <span class='mi'>512</span><span class='p'>;</span>
  <span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>effSetBlockSize</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='n'>blocksize</span><span class='p'>,</span> <span class='nb'>NULL</span><span class='p'>,</span> <span class='mf'>0.0f</span><span class='p'>);</span>

  <span class='n'>resume</span><span class='p'>();</span>
<span class='p'>}</span>
</code></pre>
</div>
<h2 id='suspending_and_resuming'>Suspending and resuming</h2>

<p>Calling the plugin&#8217;s suspend and resume methods are a bit counter-intuitive, and are done like this:</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>void</span> <span class='n'>resumePlugin</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>effMainsChanged</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>1</span><span class='p'>,</span> <span class='nb'>NULL</span><span class='p'>,</span> <span class='mf'>0.0f</span><span class='p'>);</span>
<span class='p'>}</span>

<span class='kt'>void</span> <span class='n'>suspendPlugin</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>effMainsChanged</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='nb'>NULL</span><span class='p'>,</span> <span class='mf'>0.0f</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre>
</div>
<h2 id='plugin_capabilities'>Plugin capabilities</h2>

<p>The VST protocol uses &#8220;canDo&#8221; strings to define plugin capabilities, the most common of which are defined in audioeffectx.cpp in the PlugCanDos namespace near the top of the file. To ask a plugin if it supports one of these capabilities, make the following dispatcher call:</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>bool</span> <span class='n'>canPluginDo</span><span class='p'>(</span><span class='kt'>char</span> <span class='o'>*</span><span class='n'>canDoString</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>return</span> <span class='p'>(</span><span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>effCanDo</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='p'>(</span><span class='kt'>void</span><span class='o'>*</span><span class='p'>)</span><span class='n'>canDoString</span><span class='p'>,</span> <span class='mf'>0.0f</span><span class='p'>)</span> <span class='o'>&gt;</span> <span class='mi'>0</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre>
</div>
<h2 id='host_capabilities'>Host capabilities</h2>

<p>The plugin can also ask the host if it supports a given capability, which is done through the hostCallback() function defined above. The implementation of this file looks something like this:</p>
<div class='highlight'><pre><code class='cpp'><span class='k'>extern</span> <span class='s'>&quot;C&quot;</span> <span class='p'>{</span>
<span class='n'>VstIntPtr</span> <span class='n'>VSTCALLBACK</span> <span class='n'>hostCallback</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>effect</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>opcode</span><span class='p'>,</span> <span class='n'>VstInt32</span> <span class='n'>index</span><span class='p'>,</span>
  <span class='n'>VstInt32</span> <span class='n'>value</span><span class='p'>,</span> <span class='kt'>void</span> <span class='o'>*</span><span class='n'>ptr</span><span class='p'>,</span> <span class='kt'>float</span> <span class='n'>opt</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>switch</span><span class='p'>(</span><span class='n'>opcode</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>case</span> <span class='nl'>audioMasterVersion:</span>
      <span class='k'>return</span> <span class='mi'>2400</span><span class='p'>;</span>
    <span class='k'>case</span> <span class='nl'>audioMasterIdle:</span>
      <span class='n'>effect</span><span class='o'>-&gt;</span><span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>effect</span><span class='p'>,</span> <span class='n'>effEditIdle</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>);</span>
    <span class='c1'>// Handle other opcodes here... there will be lots of them</span>
    <span class='k'>default</span><span class='o'>:</span>
      <span class='n'>printf</span><span class='p'>(</span><span class='s'>&quot;Plugin requested value of opcode %d</span><span class='se'>\n</span><span class='s'>&quot;</span><span class='p'>,</span> <span class='n'>opcode</span><span class='p'>);</span>
      <span class='k'>break</span><span class='p'>;</span>
  <span class='p'>}</span>
<span class='p'>}</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>The full list of opcodes is defined in aeffect.h (for the VST 1.x protocol) and aeffectx.h (for VST 2.x protocol). There are a lot of opcodes, and your application doesn&#8217;t need to support them all, but you will soon figure out which ones are the most important through trial and error. Depending on the nature of the opcall, you will either be required to return a given integer value, call a method in the plugin&#8217;s dispatcher, or fill the <code>*ptr</code> pointer with some type of data. The VST SDK header files have fairly good documentation specifying what you need to do depending on the opcode.</p>

<p>The <a href='http://teragonaudio.github.com/MrsWatson'>MrsWatson source code</a> also contains an example implementation of this function with the most common opcode cases.</p>

<h2 id='processing_audio'>Processing audio</h2>

<p>In the VST SDK 2.4, <code>processReplacing()</code> became the new standard call. You may have to add in support to your host for the old style of <code>process()</code> plugins, though there aren&#8217;t so many plugins out there which still do this. To have the plugin process some audio:</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>void</span> <span class='n'>processAudio</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span><span class='p'>,</span> <span class='kt'>float</span> <span class='o'>**</span><span class='n'>inputs</span><span class='p'>,</span> <span class='kt'>float</span> <span class='o'>**</span><span class='n'>outputs</span><span class='p'>,</span>
  <span class='kt'>long</span> <span class='n'>numFrames</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='c1'>// Note: If you are processing an instrument, you should probably zero</span>
  <span class='c1'>// out the input channels first to avoid any accidental noise. If you</span>
  <span class='c1'>// are processing an effect, you should probably zero the values in the</span>
  <span class='c1'>// output channels. See the silenceChannel() function below.</span>
  <span class='n'>plugin</span><span class='o'>-&gt;</span><span class='n'>processReplacing</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>inputs</span><span class='p'>,</span> <span class='n'>outputs</span><span class='p'>,</span> <span class='n'>numFrames</span><span class='p'>);</span>
<span class='p'>}</span>

<span class='kt'>void</span> <span class='n'>silenceChannel</span><span class='p'>(</span><span class='kt'>float</span> <span class='o'>**</span><span class='n'>channelData</span><span class='p'>,</span> <span class='kt'>int</span> <span class='n'>numChannels</span><span class='p'>,</span> <span class='kt'>long</span> <span class='n'>numFrames</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='k'>for</span><span class='p'>(</span><span class='kt'>int</span> <span class='n'>channel</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='n'>channels</span> <span class='o'>&lt;</span> <span class='n'>numChannels</span><span class='p'>;</span> <span class='o'>++</span><span class='n'>channel</span><span class='p'>)</span> <span class='p'>{</span>
    <span class='k'>for</span><span class='p'>(</span><span class='kt'>long</span> <span class='n'>frame</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='n'>frame</span> <span class='o'>&lt;</span> <span class='n'>numFrames</span><span class='p'>;</span> <span class='o'>++</span><span class='n'>frame</span><span class='p'>)</span> <span class='p'>{</span>
      <span class='n'>channelData</span><span class='p'>[</span><span class='n'>channel</span><span class='p'>][</span><span class='n'>frame</span><span class='p'>]</span> <span class='o'>=</span> <span class='mf'>0.0f</span><span class='p'>;</span>
    <span class='p'>}</span>
  <span class='p'>}</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Note that you need to properly allocate the arrays for the audio inputs and outputs depending on your blocksize and channel count. Like a regular VST plugin, this structure is simply a de-interlaced array ordered by channel of the sample block data, with the left channel being the first one. You should also take care to properly initialize the data in both the inputs and outputs array to zero, or else you can get static or other random noise in the processed signal.</p>

<h2 id='sending_midi_messages'>Sending MIDI messages</h2>

<p>Processing MIDI events is very similar to processing audio:</p>
<div class='highlight'><pre><code class='cpp'><span class='kt'>void</span> <span class='n'>processMidi</span><span class='p'>(</span><span class='n'>AEffect</span> <span class='o'>*</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>VstEvents</span> <span class='o'>*</span><span class='n'>events</span><span class='p'>)</span> <span class='p'>{</span>
  <span class='n'>dispatcher</span><span class='p'>(</span><span class='n'>plugin</span><span class='p'>,</span> <span class='n'>effProcessEvents</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='n'>events</span><span class='p'>,</span> <span class='mf'>0.0f</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>The above events array should be allocated and properly initialized by the host to contain the MIDI events which the plugin will receive. The <code>VstEvent</code> structure is defined in aeffectx.h, and there you will also find the respective <code>VstEvent</code> types, all of which are deprecated except for <code>kVstMidiType</code> and <code>kVstSysExType</code>.</p>

<p>Note that the plugin must support the <code>receiveVstMidiEvent</code> canDo in order to process MIDI.</p>

<h2 id='final_notes'>Final Notes</h2>

<p>At this point, you should have a basic working host capable of loading and communicating with a VST plugin. As you continue your development, take care to thoroughly read the VST SDK header files and other associated documentation, as they will provide you with further hints as to the correct implementation. Also, you should take time to create good logging facilities in your host, particularly in the <code>hostCallback()</code> method, as most plugin incompatibilities are usually triggered from some error there.</p>
        <!-- End content -->
      </div>									
      <div style="clear:both;"></div>
        <div id="bottom">
          <p class="footer">
            <b>Questions or comments?</b> Send an email to
            <script>mail2("info", "teragonaudio", 0, "subject=How to make your own VST host", "info at teragonaudio dot com")</script>.
            Copyright (c) 2012 Teragon Audio. All Rights Reserved.

          </p>
        </div>
      </div>								
    </div>
  </body>
</html>
